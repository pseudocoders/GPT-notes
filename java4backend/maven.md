# Maven


Maven is a widely used build automation and dependency management tool for Java projects. It provides a structured and standardized way to manage project dependencies, build processes, and project documentation. Maven uses an XML-based configuration file called `pom.xml` (Project Object Model) to define project settings, dependencies, and build instructions.

Here are some key concepts and features of Maven:

1. Project Object Model (POM): The POM is an XML file that serves as the project's central configuration file. It defines the project's structure, dependencies, plugins, build profiles, and other project-related information. The POM provides a declarative approach to managing project configurations and allows Maven to handle various aspects of the project's lifecycle.

2. Dependency Management: Maven simplifies managing project dependencies. Dependencies are external libraries or modules required by the project. In the POM, you specify the dependencies your project needs, including their version numbers and other relevant details. Maven automatically downloads the required dependencies from remote repositories and resolves conflicts between different versions of dependencies.

3. Build Lifecycle: Maven defines a standard build lifecycle consisting of phases and goals. Phases represent different stages of the build process, such as compiling source code, packaging artifacts, running tests, and deploying. Goals are specific tasks executed within each phase. Maven provides default lifecycle bindings, but you can also customize and extend the build process by configuring additional plugins and their goals.

4. Plugins: Plugins are Maven's key building blocks. They extend the build process and provide additional functionality to the project. Plugins are configured in the POM file, and they perform tasks like compiling code, generating documentation, running tests, packaging the application, deploying artifacts, and more. Maven has a vast collection of plugins available, and you can also develop custom plugins to meet specific project requirements.

5. Repository Management: Maven uses repositories to store and retrieve dependencies, plugins, and other artifacts. It supports local repositories on developers' machines and remote repositories accessible over the internet. Maven Central Repository is the default remote repository, containing a vast number of open-source libraries and plugins. Additionally, you can set up private repositories to host proprietary or internal dependencies.

6. Convention over Configuration: Maven follows the principle of "convention over configuration." It promotes standard project structures and naming conventions. By adhering to these conventions, Maven can infer project settings, making the build process more intuitive and less configuration-heavy. This standardization simplifies project maintenance and promotes collaboration across different Maven-based projects.

Maven brings several benefits to the software development process, including:

- Dependency management: Maven handles the download, management, and resolution of project dependencies, reducing the burden on developers.
- Build automation: Maven automates the build process, making it easy to compile, test, package, and deploy projects consistently across different environments.
- Standardization: Maven's conventions and structure make it easier for developers to understand and work on projects, enabling better collaboration and code sharing.
- Extensibility: Maven's plugin architecture allows developers to add custom functionality or use existing plugins to perform various tasks, enhancing project capabilities.
- Continuous Integration (CI) support: Maven integrates well with CI tools like Jenkins, Bamboo, and others, enabling automated builds, tests, and deployments in a CI/CD pipeline.

Maven has become a widely adopted tool in the Java ecosystem due to its powerful features, strong community support, and robust dependency management capabilities. It simplifies project setup, enhances developer productivity, and ensures consistent and reliable build processes.


## pom.xml

The `pom.xml` (Project Object Model) is an XML file used by Apache Maven to define and configure Java projects. It serves as the central configuration file for the project and contains various settings, dependencies, plugins, and build instructions. Let's delve deeper into the different sections and elements of the `pom.xml` file:

1. Project Information:
   - `groupId`: Specifies the unique identifier for the project's group or organization.
   - `artifactId`: Defines the project's unique identifier or name.
   - `version`: Specifies the version of the project.
   - `packaging`: Determines the type of artifact generated by the project (e.g., jar, war, pom).

2. Project Dependencies:
   - `<dependencies>`: This section lists the dependencies required by the project. Each dependency is specified using `<dependency>` tags, including the `groupId`, `artifactId`, and `version` of the dependency. Maven automatically resolves and downloads these dependencies from remote repositories.
   - `<dependencyManagement>`: If used, this section allows centralized management of dependencies across multiple modules or projects. It defines the versions of dependencies that should be used and can help ensure consistency across the project.

3. Build Configuration:
   - `<build>`: This section contains instructions for building the project.
   - `<plugins>`: Defines the plugins used in the build process. Plugins provide additional functionality or execute specific tasks during the build lifecycle. Each plugin is specified using `<plugin>` tags, including the `groupId`, `artifactId`, and `version` of the plugin. Plugins can be customized to perform tasks such as compiling code, running tests, generating documentation, packaging the application, and more.

4. Build Lifecycle:
   Maven follows a predefined build lifecycle with various phases and goals. The build lifecycle is defined within the `<build>` section using `<lifecycleMappingMetadata>` or `<pluginManagement>` tags. Goals are executed during specific phases of the build process and can be bound to a specific plugin execution.

5. Profiles:
   - `<profiles>`: Profiles allow you to define alternative configurations for different environments or build scenarios. They are useful for specifying settings specific to development, testing, production, or other custom environments. Profiles can be activated based on various conditions, such as the presence of specific properties or command-line options.

6. Repositories:
   - `<repositories>`: This section specifies the remote repositories from which Maven should download dependencies. Maven Central Repository is the default remote repository. You can also configure additional repositories, including private or custom repositories.
   - `<pluginRepositories>`: Similar to `<repositories>`, this section defines the remote repositories from which Maven should retrieve plugins.

7. Reporting and Documentation:
   - `<reporting>`: Maven provides a range of built-in reporting plugins to generate various project reports, such as test results, code coverage, and project documentation. The `<reporting>` section allows configuring and customizing these reports.

8. Properties:
   - `<properties>`: This section allows you to define and configure project-specific properties. Properties can be used to specify common values, such as the Java version, project URLs, or any custom configuration values used within the `pom.xml` file.

The `pom.xml` file provides a centralized configuration for Maven projects, enabling consistent builds, dependency management, and build lifecycle execution. It allows developers to define project-specific information, manage dependencies, customize the build process, and generate reports. By following the conventions of the `pom.xml` file, Maven can automate various aspects of the development workflow, enhancing project organization and maintainability.

### Example

Here's an example `pom.xml` file for a simple Java project:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>myproject</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <properties>
        <java.version>11</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.12.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

In this example:

- The `<groupId>`, `<artifactId>`, and `<version>` elements identify the project. The `groupId` represents the project's group or organization, `artifactId` is the project's unique identifier or name, and `version` specifies the project version.
- The `<packaging>` element determines the type of artifact generated by the project. In this case, it is a JAR file.
- The `<properties>` section allows defining project-specific properties. Here, we have set the `java.version` property to `11` to specify that the project should be compiled using Java 11.
- The `<dependencies>` section lists the project's dependencies. In this example, we have a dependency on the Apache Commons Lang library (version 3.12.0).
- The `<build>` section contains build-related configurations. In this case, we have configured the Maven Compiler Plugin to use Java 11 as the source and target version for compilation.

This is a basic example, but the `pom.xml` file can be extended to include various other configurations, plugins, repositories, profiles, and more. The file provides a structured way to define project settings, dependencies, and build instructions, enabling Maven to manage the project's build process and handle dependency resolution.

## Archetypes

In Maven, an archetype is a project templating toolkit that allows you to generate project structures and initial configurations based on predefined templates. It provides a convenient way to bootstrap new projects with a predefined structure and set of files, including source code directories, resource files, configuration files, and other project-specific elements.

Maven archetypes define the structure and content of a project template, which can be used as a starting point for creating new projects. They capture best practices, standard configurations, and common project setups, enabling developers to quickly set up projects with consistent conventions and configurations.

Archetypes consist of the following components:

1. Project Structure: Archetypes define the directory structure and organization of the generated project. This includes source code directories, resource directories, test directories, and other commonly used directories.

2. Project Files: Archetypes specify the initial set of files that should be included in the generated project. This may include configuration files (e.g., `pom.xml`, `web.xml`), build scripts (e.g., `build.gradle`, `webpack.config.js`), and other project-specific files.

3. Dependency Management: Archetypes can include predefined dependencies and their versions. This allows for the automatic inclusion of commonly used libraries and frameworks in the generated project, reducing the manual effort of setting up dependencies.

4. Configuration: Archetypes can provide initial configurations for tools, plugins, and frameworks used in the project. This includes setting up default build configurations, code style rules, code generation templates, and more.

Maven provides a set of built-in archetypes, such as `maven-archetype-quickstart`, `maven-archetype-webapp`, and `maven-archetype-j2ee-simple`. These archetypes cover common project types, such as basic Java projects, web applications, and Java EE applications. You can generate a project based on these archetypes using the `mvn archetype:generate` command and selecting the desired archetype.

In addition to the built-in archetypes, you can also create custom archetypes to meet specific project requirements. Custom archetypes allow you to define project structures and configurations tailored to your organization's needs or specific project setups. Maven provides a tool called `archetype-plugin` to create and install custom archetypes.

Using archetypes, developers can quickly create new projects based on predefined templates, ensuring consistency and adherence to project conventions. Archetypes simplify project setup and reduce repetitive manual work, enabling teams to focus on developing their application logic rather than dealing with project infrastructure.

## Maven goals

In Apache Maven, goals are specific tasks or operations that can be executed during the build process. Goals are executed within different phases of the build lifecycle. Maven provides a set of predefined goals, and you can also define custom goals using plugins.

Here are some commonly used Maven goals and their associated build phases:

1. `clean`: This goal is bound to the `clean` phase and is used to clean up the build artifacts and temporary files generated by the previous build.

2. `compile`: This goal is bound to the `compile` phase and is responsible for compiling the project's source code, typically located in the `src/main/java` directory, into bytecode.

3. `test`: This goal is bound to the `test` phase and executes the project's unit tests located in the `src/test/java` directory.

4. `package`: This goal is bound to the `package` phase and is used to package the compiled code and resources into an artifact. The default artifact type is a JAR, but it can be configured to create other types like a WAR or an EAR.

5. `install`: This goal is bound to the `install` phase and installs the project artifact into the local Maven repository. The artifact is stored in the local repository, making it available for other local projects to use as a dependency.

6. `deploy`: This goal is bound to the `deploy` phase and deploys the project artifact to a remote repository or a deployment target, making it available for other projects or developers.

These are just a few examples of commonly used Maven goals. Maven provides a wide range of other goals for various purposes, such as generating project documentation, running static code analysis, generating reports, executing integration tests, and more.

You can execute a specific goal using the command `mvn <goal>`. For example, `mvn compile` executes the `compile` goal, and `mvn test` executes the `test` goal.

In addition to the predefined goals, you can also define custom goals by configuring plugins in the `pom.xml` file. Plugins can provide additional functionality and execute custom tasks as part of the build process. You can bind custom goals to specific phases or configure them to run on-demand.

Maven's goal-oriented approach allows for fine-grained control over the build process, enabling developers to execute specific tasks at different stages of the project lifecycle. This makes it easier to manage dependencies, compile code, run tests, package artifacts, and perform other build-related operations in a consistent and repeatable manner.

## Lifecycles

The Maven project lifecycle defines a series of phases and goals that a Maven project goes through during the build process. Each phase represents a specific stage of the project's lifecycle, and goals are associated with these phases to perform specific tasks or operations. The Maven build lifecycle consists of three primary lifecycles: default, clean, and site.

1. Default Lifecycle:
   The default lifecycle is the core lifecycle of a Maven project. It consists of the following phases:

   - `validate`: Validates the project structure and configuration.
   - `compile`: Compiles the project's source code.
   - `test`: Runs tests against the compiled source code.
   - `package`: Packages compiled code and resources into an artifact.
   - `verify`: Performs any checks to verify the package is valid and meets quality criteria.
   - `install`: Installs the artifact into the local Maven repository.
   - `deploy`: Deploys the artifact to a remote repository or deployment target.

   By default, all these phases are executed sequentially. For example, when you run `mvn install`, Maven will execute all the phases up to the `install` phase.

2. Clean Lifecycle:
   The clean lifecycle is responsible for cleaning up the build artifacts and temporary files generated by the previous build. It consists of a single phase:

   - `clean`: Removes the generated build artifacts and files.

   When you run `mvn clean`, Maven will execute the `clean` phase, deleting the target directory and other generated files.

3. Site Lifecycle:
   The site lifecycle is used for generating project documentation and reports. It consists of the following phases:

   - `pre-site`: Executes any pre-site processing or preparation.
   - `site`: Generates project documentation and site-specific files.
   - `post-site`: Executes any post-site processing or cleanup.
   - `site-deploy`: Deploys the generated site to a remote location for hosting.

   The `site` phase generates the project's documentation, reports, and other site-related artifacts. Running `mvn site` executes all the phases up to `site`, generating the project's documentation.

In addition to these primary lifecycles, Maven also provides extension mechanisms to define custom lifecycles and bind goals to specific phases. This allows for further customization and integration of additional build processes and plugins into the project's lifecycle.

The Maven project lifecycle provides a standardized and consistent way to manage the build process. It ensures that the necessary tasks, such as compiling code, running tests, packaging artifacts, and generating documentation, are executed in the appropriate order. By leveraging the lifecycles and associated phases and goals, developers can build and maintain projects efficiently, following best practices and conventions established by the Maven framework.

## Plugins 

In Maven, plugins are extensions that provide additional functionality and capabilities to the build process. They are used to perform specific tasks, such as compiling code, running tests, generating reports, packaging artifacts, deploying applications, and more. Plugins are an essential part of Maven's build system and can be configured in the `pom.xml` file.

Maven plugins are self-contained units that encapsulate specific tasks or operations. They are responsible for executing these tasks at the appropriate phase of the build lifecycle or on-demand. Plugins can be either built-in plugins provided by Maven itself or custom plugins developed by third parties or by yourself.

Here are some key points about Maven plugins:

1. Plugin Configuration: Each plugin has its own set of configurable parameters and goals that can be customized in the `pom.xml` file. These configurations allow you to specify the behavior, options, and inputs for the plugin's tasks.

2. Plugin Execution: Plugins are associated with specific phases of the build lifecycle, and their goals are executed within those phases. For example, the `maven-compiler-plugin` is bound to the `compile` phase and is responsible for compiling source code. When Maven reaches the `compile` phase, it automatically executes the `compile` goal of the compiler plugin.

3. Dependency Management: Plugins can have their own dependencies, which are separate from project dependencies. Maven manages these plugin dependencies independently, resolving and downloading them from repositories. These dependencies are used by the plugins to provide their functionality.

4. Built-in Plugins: Maven provides a set of built-in plugins that cover a wide range of common build tasks. These plugins are included by default and can be used without any additional configuration. Examples of built-in plugins include `maven-compiler-plugin`, `maven-surefire-plugin` for running tests, `maven-jar-plugin` for packaging JAR files, and `maven-deploy-plugin` for deploying artifacts.

5. Custom Plugins: If the built-in plugins do not fulfill your specific requirements, you can create custom plugins. Custom plugins allow you to extend Maven's capabilities and perform project-specific tasks. Custom plugins are typically developed using Java and can be added to the project or installed in a local or remote Maven repository.

To use a plugin, you specify its configuration within the `<plugins>` section of the `pom.xml` file. You can configure the plugin's parameters, specify the goals to be executed, and set their respective configurations.

Maven plugins enhance the build process by providing additional functionality beyond what is available in the default lifecycle. They enable developers to extend Maven's capabilities, automate tasks, integrate with external tools, and customize the build process according to project requirements.

## The build process and dependencies

By default, Maven does not include dependencies in the final JAR file during the build process. Instead, Maven resolves and downloads the project dependencies from remote repositories and manages them separately. The resulting JAR file generated by Maven only includes the project's own compiled classes and resources.

Maven follows a convention where it separates the project's dependencies from its own artifacts. This separation allows for better modularity and reusability of dependencies across multiple projects.

When you build a Maven project, Maven resolves the dependencies declared in the `pom.xml` file and downloads them to the local Maven repository (usually located in the `.m2` directory in the user's home directory). It then uses the resolved dependencies during the build process, such as compiling and running tests, but they are not bundled within the final JAR.

However, there are Maven plugins available that can help create an "uber" JAR or an executable JAR that includes all the project dependencies. These plugins, such as the Maven Shade Plugin or the Maven Assembly Plugin, can be configured to package the project's dependencies along with the project's own classes and resources into a single JAR file. This can be useful for creating standalone executable JARs or for projects that need to be distributed as a self-contained package.

If you require the project's dependencies to be included in the final JAR during the build process, you would need to configure and use one of these Maven plugins to achieve that behavior.
